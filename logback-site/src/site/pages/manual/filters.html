<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <title>Chapter 6: Filters</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print" />


  </head>
  <body>
    <script type="text/javascript">prefix='../';</script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <div id="left">
      <noscript>Please turn on Javascript to view this menu</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
	
    <h1>Chapter 6: Filter chains</h1>

    <div class="quote">
      <p><em>Have lots of ideas and throw away the bad ones. You aren't
      going to have good ideas unless you have lots of ideas and some
      sort of principle of selection.</em></p>
      
      <p>&mdash;LINUS PAULING</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>

		
		<p>As we have seen, logback has several built-in ways for
			filtering log requests, including the context-wide filter,
			logger-level selection rule and appender filters.  These provide
			high performance filtering for the most commonly encountered
			cases. These filters are largely inspired from Linux ipchains or
			iptables as they are called in more recent Linux kernels.
			Logback filters are based on ternary logic allowing them to be
			assembled or chained together to compose an arbitrarily complex
			filtering policy.
		</p>

    <script src="../templates/setup.js" type="text/javascript"></script>

		<p>
			There are two main types of filters, namely <code>Filter</code> and 
			<code>TurboFilter</code>.
		</p>
		
		<h2>Logback Classic</h2>
		
		<a name="Filter"></a>

		<p><code>Filter</code> objects all extend the <a
		href="../xref/ch/qos/logback/core/filter/Filter.html"><code>Filter</code></a>
		abstract class. The <code>decide(Object event)</code> method is
		passed a newly created <code>LoggingEvent</code> object.
		</p>
		
		<h3>Filter chains</h3>

		<p>This abstract class assumes that filters are organized in a
		linear chain.  Its member field next points to the next filter in
		the chain, or <code>null</code> if there are no further filters in
		the chain.  Figure 6.1 depicts a sample filter chain consisting of
		three filters.
		</p>
		
		<img src="images/chapter6/filterChain.gif" alt="A sample filter chain"/>

    <p>Filters are based on ternary logic. The <code>decide(Object
    event)</code> method of each filter is called in sequence.  This
    method returns one of the <a
    href="../xref/ch/qos/logback/core/spi/FilterReply.html"><code>FilterReply</code></a>
    enumeration values, i.e. one of <code>FilterReply.DENY</code>,
    <code>FilterReply.NEUTRAL</code> or
    <code>FilterReply.ACCEPT</code>.  If the returned value is
    <code>FilterReply.DENY</code>, then the log event is dropped
    immediately without consulting the remaining filters. If the value
    returned is <code>FilterReply.NEUTRAL</code>, then the next filter
    in the chain is consulted. If there are no further filters to
    consult, then the logging event is processed normally.  If the
    returned value is <code>FilterReply.ACCEPT</code>, then the
    logging event is processed immediately skipping the remaining
    filters.
    </p>
    
    <p>In logback-classic <code>Filter</code> objects can only be
    added to <code>Appender</code> instances. By adding filters to an
    appender you can filter events by various criteria, such as the
    contents of the log message, the contents of the MDC, the time of
    day or any other part of the logging event.
    </p>
    
		<h3>Implementing your own Filter</h3>
		
		<p>Creating your own filter is not difficult. All you have to do
		is extend the <code>Filter</code> abstract class. The only method
		that you will have to implement is the <code>decide()</code>
		method, allowing you to contentrate only on the behaviour of your
		filter.
		</p>
		
		<p>The next class is all it takes to implement one's own
		filter. All it does is accept logging events who's message
		contains the String <em>sample</em>. The filter will give a
		neutral response to any logging event who's message does not
		contain this String.
		</p>
		
<em>Example 6.1: Basic custom filter (<a href="../xref/chapter6/SampleFilter.html">logback-examples/src/main/java/chapter6/SampleFilter.java</a>)</em>		
<div class="source"><pre>package chapter6;

import ch.qos.logback.classic.spi.LoggingEvent;
import ch.qos.logback.core.filter.Filter;
import ch.qos.logback.core.spi.FilterReply;

public class SampleFilter extends Filter {

  @Override
  public FilterReply decide(Object eventObject) {
    LoggingEvent event = (LoggingEvent)eventObject;
    
    if (event.getMessage().contains("sample")) {
      return FilterReply.ACCEPT;
    } else {
      return FilterReply.NEUTRAL;
    }
  }
}</pre></div>

		<p>
			What is shown above might be the simplest filter. Like any filter, it
			can be attached to any appender using the &lt;Filter&gt; element, as
			shown below:
		</p>

<em>Example 6.2: SampleFilter configuration (logback-examples/src/main/java/chapter6/SampleFilterConfig.xml)</em>				
<div class="source"><pre>&lt;configuration>
  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;Filter class="chapter6.SampleFilter" /></b>

    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>
	
  &lt;root>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre></div>

		<p>Thanks to Joran, logback's powerful configuration framework,
		adding an option to such a filter is very easy. Just add the
		corresponding getter and setter methods in the class, and you can
		specify the option's value in an xml element, nested within the
		<em>filter</em> element.
		</p>
		
		<p>In case you want to implement a filter that provides different
		behaviour depending on the result of its test (say, a filter that
		would accept or deny an event depending on the content of its
		message), you can extend the
			<a href="../xref/ch/qos/logback/core/filter/AbstractMatcherFilter.html">
			<code>AbstractMatcherFilter</code></a> class. It will provide your filter with 
			two attribute: <em>OnMatch</em> and <em>OnMismatch</em>, that can be configured
			like any other option.
		</p>
		
		<h3>Logback Filters</h3>
		
		<p>At the moment, there are two filters that ship with logback. <a
		href="../xref/ch/qos/logback/classic/LevelFilter.html">
		<code>LevelFilter</code></a> provides event filtering based on a
		<code>Level</code> value.  It the event's level is equal to the
		configured level, the filter accepts of denies the event,
		depending on its configuration. It allows you to choose the
		behaviour of logback for a precise given level. Here is a sample
		configuration that uses <code>LevelFilter</code>.
		</p>
		
<em>Example 6.3: Sample LevelFilter configuration (logback-examples/src/main/java/chapter6/levelFilterConfig.xml)</em>				
<div class="source"><pre>&lt;configuration>
  &lt;appender name="CONSOLE"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.classic.filter.LevelFilter">
      &lt;level>INFO&lt;/level>
      &lt;onMatch>ACCEPT&lt;/onMatch>
      &lt;onMismatch>DENY&lt;/onMismatch>
    &lt;/filter></b>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>
  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre></div>

		<p>
			The second filter that ships with logback is 
			<a href="../xref/ch/qos/logback/classic/ThresholdFilter.html">
			<code>ThresholdFilter</code></a>.
			It is also based on level value, but acts as a threshold to deny any request
			whose level is not equal or greater to the configured level. A sample
			use of the <code>ThresholdFilter</code> is shown below.
		</p>

<em>Example 6.4: Sample ThresholdFilter configuration (logback-examples/src/main/java/chapter6/thresholdFilterConfig.xml)</em>				
<div class="source"><pre>&lt;configuration>
  &lt;appender name="CONSOLE"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      &lt;level>INFO&lt;/level>
    &lt;/filter></b>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>
  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre></div>


    <h3>Evaluator Filters taking Java Expressions</h3>

		    
    <p>A special category of filters is implemented by the <a
    href="../xref/ch/qos/logback/core/filter/EvaluatorFilter.html">
    <code>EvaluatorFilter</code></a> class. These filters use an <a
    href="../xref/ch/qos/logback/core/boolex/EventEvaluator.html">
    <code>EventEvaluator</code></a> object to decide wether to accept
    or deny a request. This allows unprecedented flexibility in the
    way that you can affect filtering of logging events.
    </p>

    <p>As a user, you do not need to worry about the actual
    plumbing. All you need to do is to give a name to the evaluator
    and to specify an <em>evaluation expression</em>, that is a
    boolean expression in regular Java syntax. These evaluation
    expressions are compiled on-the-fly during the interpretation of
    the configration file. It is the users reponsibility to ensure
    that the expression is boolean, that it evaluates to true or
    false.  In evaluation expressions, logback implicitly exposes
    various fields of a logging event as variables. The list of these
    implicit variables is given below. The scope of evaluation
    expressions is limited to the logging event.
		</p>
		
		
		<table class="bodyTable">
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
			</tr>
      <tr>
				<td>event</td>
				<td><code>LoggingEvent</code></td>

        <td>The raw logging event associated with the logging
        request. All of the following variables are also available
        from the event. For example, <code>event.getMessage()</code>
        returns the same String value as the <em>message</em> variable
        described next.
        </td>
			</tr>

      <tr class="alt">
				<td>message</td>
        <td><code>String</code></td>
        <td>The message of the logging request.</td>
			</tr>
			<tr>
				<td>logger</td>
				<td><code>LoggerRemoteView</code></td>
				<td>This object is a proxy for the logger object where the
				logging request was issued. It can be viewed as a regular
				logger object. However, it has some nice performance
				properties, especially with respect to serialization.
        </td>
			</tr>

			<tr  class="alt">
				<td>level</td>
				<td><code>int</code></td>
				<td>The int value corresponding to the level. To help create
				easily expressions involving levels, the default value
				<em>DEBUG</em>, <em>INFO</em>, <em>WARN</em> and
				<em>ERROR</em> are also available. Thus, using <em>level &gt;
				INFO</em> is a correct expression.
				</td>
			</tr>
			<tr>
				<td>timeStamp
				</td>
				<td><code>long</code></td>
				<td>The timestamp corresponding to the logging event's
				creation.
				</td>
			</tr>
			<tr  class="alt">
				<td>marker</td>
				<td><code>Marker</code></td>
        <td>The <code>Marker</code> object associated with the logging
        request.
				</td>
			</tr>
			<tr>
				<td>mdc
				</td>
				<td><code>Map</code></td>
				<td>A map containing all the MDC values at the time of the 
				creation of the logging event. A value can be access by using the
				following expression: <em>mdc.get("myKey")</em>.
				</td>
			</tr>
			<tr  class="alt">
				<td>throwable</td>
				<td><code>Throwable</code></td>
				<td>The exception associated with the logging event
				</td>
			</tr>
		</table>

		
		<p>The behaviour of the <code>EvaluatorFilter</code> is also
		affected by its <span class="option">OnMatch</span> and <span
		class="option">OnMismatch</span> options taking values of type
		<code>FilterReply</code>, i.e. DENY, ACCEPT, NEUTRAL.
    </p>
    
    <p>Here is a concrete example.</p>

<em>Example 6.5: Basic event evaluator usage (logback-examples/src/main/java/chapter6/basicEventEvaluator.xml)</em>

<div class="source"><pre>&lt;configuration>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator name="myEval">
        &lt;expression><span class="green">message.contains("billing")</span>&lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>DENY&lt;/OnMatch>
    &lt;/filter></b>
    &lt;layout>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="INFO">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre></div>

		<p>The bold part in the previous configuration adds an
		<code>EvaluatorFilter</code> to a <code>ConsoleAppender</code>. An
		<code>EventEvaluator</code> is then injected into the
		<code>EvaluatorFilter</code>. The <em>expression</em> element
		corresponds to the evaluation expression described previously. The
		expression <code>message.contains("billing")</code> returns a
    boolean value. Notice that the <em>message</em> variable is
		defined implicitly.
    </p>

		<p>This evalutor filter will drop all logging events whose message
		contains the string "billing".
    </p>

    <p>The <a
    href="../xref/chapter6/FilterEvents.html"><code>FilterEvents</code></a>
    application issues ten logging requests, numbered 0 to 9. Let us
    rist run <code>FilterEvents</code> class without any filters:
		</p>
		
<div class="source"><pre>
java chapter6.FilterEvents src/main/java/chapter6/basicConfiguration.xml
</pre></div>
		
		<p>All requests will be displayed, as shown below:</p>

<div class="source"><pre>0    [main] INFO  chapter6.FilterEvents - logging statement 0
0    [main] INFO  chapter6.FilterEvents - logging statement 1
0    [main] INFO  chapter6.FilterEvents - logging statement 2
0    [main] DEBUG chapter6.FilterEvents - logging statement 3
0    [main] INFO  chapter6.FilterEvents - logging statement 4
0    [main] INFO  chapter6.FilterEvents - logging statement 5
0    [main] ERROR chapter6.FilterEvents - <b>billing statement 6</b>
0    [main] INFO  chapter6.FilterEvents - logging statement 7
0    [main] INFO  chapter6.FilterEvents - logging statement 8
0    [main] INFO  chapter6.FilterEvents - logging statement 9</pre></div>



		<p>Suppose that we want to get rid of the billing information.
		The <em>basicEventEvaluator.xml</em> configuration file just
		desribed, does exactly what we want.</p>

    <p>Running with filters:</p>
    <p class="source">java chapter6.FilterEvents src/main/java/chapter6/basicEventEvaluator.xml</p>
    <p>we obtain:
		</p>
		
    <p class="source">0    [main] INFO  chapter6.FilterEvents - logging statement 0
0    [main] INFO  chapter6.FilterEvents - logging statement 1
0    [main] INFO  chapter6.FilterEvents - logging statement 2
0    [main] DEBUG chapter6.FilterEvents - logging statement 3
0    [main] INFO  chapter6.FilterEvents - logging statement 4
0    [main] INFO  chapter6.FilterEvents - logging statement 5
0    [main] INFO  chapter6.FilterEvents - logging statement 7
0    [main] INFO  chapter6.FilterEvents - logging statement 8
0    [main] INFO  chapter6.FilterEvents - logging statement 9</p>
		
		
    <h2><a name="TurboFilter" href="#TurboFilter">TurboFilters</a></h2>
    
    <p><code>TurboFilter</code> objects all extend the
    	<a href="../xref/ch/qos/logback/classic/turbo/TurboFilter.html">
    	<code>TurboFilter</code></a> abstract class. Like the regular
    	filters, they use ternary logic to return their evaluation of
    	the logging event.
    </p>
    
    <p>Overall, they work much like the previously mentionned
    filters. However, there are two main differences between
    <code>Filter</code> and <code>TurboFilter</code> objects.
    </p>
    
   	<p><code>TurboFilter</code> objects are tied to the logging
   	context. Hence, they are called not only when a given appender is
   	used, but each and every time a logging request is issued. Their
   	scope is wider than appender-attached filters.
   	</p>
   	
   	<p>More importantly, they are called before the
   	<code>LoggingEvent</code> object creation.
   	<code>TurboFilter</code> objects do not require the instantiation
   	of a logging event to filter a logging request. As such, turbo
   	filters are intended for high performance filtering of logging
   	event, even before they are created.
    </p>

   	
   	<h3>Implementing your own TurboFilter</h3>
    
    <p>
      To create your own <code>TurboFilter</code> component, just extend the 
      <code>TurboFilter</code> abstract class. As previously, when implementing
      a custumized filter object, developing a custom <code>TurboFilter</code> only
      ask that one implement the <code>decide()</code> method. In the next example, we
      create a slightly more complex filter:
    </p>
    
<em>Example 6.6: Basic custom <code>TurboFilter</code> (<a href="../xref/chapter6/SampleTurboFilter.html">logback-examples/src/main/java/chapter6/SampleTurboFilter.java</a>)</em>		
<div class="source"><pre>package chapter6;

import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.turbo.TurboFilter;
import ch.qos.logback.core.spi.FilterReply;

public class SampleTurboFilter extends TurboFilter {

  String marker;
  Marker markerToAccept;

  @Override
  public FilterReply decide(Marker marker, Logger logger, Level level,
      String format, Object[] params, Throwable t) {

    if (!isStarted()) {
      return FilterReply.NEUTRAL;
    }

    if ((markerToAccept.equals(marker))) {
      return FilterReply.ACCEPT;
    } else {
      return FilterReply.NEUTRAL;
    }
  }

  public String getMarker() {
    return marker;
  }

  public void setMarker(String markerStr) {
    this.marker = markerStr;
  }

  @Override
  public void start() {
    if (marker != null &amp;&amp; marker.trim().length() > 0) {
      markerToAccept = MarkerFactory.getMarker(marker);
      super.start(); 
    }
  }
}
</pre></div>

		<p>The <code>TurboFilter</code> above accepts events that contain
		a specific marker.  If said marker is not found, then the filter
		passes the responsability to the next filter in the chain.
		</p>
		
		<p>To allow more flexibility, the marker that will be tested can
		be specified in the configuration file. Hence the getter and
		setter methods. We also implemented the <code>start()</code>
		method, to check that the option has been specified during the
		configuration process.
		</p>
		
		<p>Here is a sample configuration that makes use of our newly
		created <code>TurboFilter</code>.
		</p>
		
<em>Example 6.7: Basic custom <code>TurboFilter</code> configuration (logback-examples/src/main/java/chapter6/sampleTurboFilterConfig.xml)</em>		
<div class="source"><pre>&lt;configuration>
  <b>&lt;turboFilter class="chapter6.SampleTurboFilter">
    &lt;Marker>sample&lt;/Marker>
  &lt;/turboFilter></b>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre></div>   

   	<p>Logback classic ships with several <code>TurboFilter</code>
   	classes ready for use.  The <a
   	href="../xref/ch/qos/logback/classic/turbo/MDCFilter.html"><code>MDCFilter</code></a>
   	check the presence of a given value in the MDC whereas <a
   	href="../apidocs/ch/qos/logback/classic/turbo/DynamicThresholdFilter.html"><code>DynamicThresholdFilter</code></a>
   	allows filtering based on MDC key/level thresold associations. On
   	the other hand, <a
   	href="../xref/ch/qos/logback/classic/turbo/MarkerFilter.html"><code>MarkerFilter</code></a>
   	checks for the presence of a specific marker associated with the
   	logging request.
   	</p>
   	
   	<p>Here is a sample configuration, using both
   	<code>MDCFilter</code> and <code>MarkerFilter</code>.
   	</p>
   	
<em>Example 6.8: <code>MDCFilter</code> and <code>MarkerFilter</code> 
configuration (logback-examples/src/main/java/chapter6/turboFilters.xml)</em>
<div class="source"><pre>&lt;configuration>

  &lt;turboFilter class="ch.qos.logback.classic.turbo.MDCFilter">
    &lt;MDCKey>username&lt;/MDCKey>
    &lt;Value>sebastien&lt;/Value>
    &lt;OnMatch>ACCEPT&lt;/OnMatch>
  &lt;/turboFilter>
	
  &lt;turboFilter class="ch.qos.logback.classic.turbo.MarkerFilter">
    &lt;Marker>billing&lt;/Marker>
    &lt;OnMatch>DENY&lt;/OnMatch>
  &lt;/turboFilter>

  &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%date [%thread] %-5level %logger - %msg%n&lt;/Pattern>
  &lt;/layout>
  &lt;/appender>

  &lt;root level="info">
    &lt;appender-ref ref="console" />
  &lt;/root>  
&lt;/configuration></pre></div>

		<p>You can see this configuration in action by issuing the
		following command:
		</p>
    
    <p class="source">java chapter6.FilterEvents src/main/java/chapter6/turboFilters.xml</p>

		<p>As we've seen previously, the <a
		href="../xref/chapter6/FilterEvents.html"><code>FilterEvents</code></a>
		application issues 10 logging requests, numbered 0 to 9. Except
		for requests 3 and 6, all of the requests are of level
		<em>INFO</em>, the same level as the one assigned to the root
		logger. The 3rd request, is issued at the the <em>DEBUG</em>
		level, which is below the effective level. However, since the MDC
		key "username" is set to "sebastien" just before the 3rd request
		and removed just afterwards, the <code>MDCFilter</code>
		specifically accepts the request (and only that request). The 6th
		request, issued at the <em>ERROR</em> level, is marked as
		"billing". As such, it is denied by the MarkerFilter (the second
		turbo filter in the configuration).
		</p>
		
		<p>Thus, the output of <code>FilterEvents</code> application
		configured with <em>turboFilters.xml</em> file shown above is:
		</p>

    <p class="source">2006-12-04 15:17:22,859 [main] INFO  chapter6.FilterEvents - logging statement 0
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 1
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 2
2006-12-04 15:17:22,875 [main] DEBUG chapter6.FilterEvents - logging statement 3
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 4
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 5
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 7
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 8
2006-12-04 15:17:22,875 [main] INFO  chapter6.FilterEvents - logging statement 9</p>
			
			
		<p>One can see that the 3rd request, which should not be displayed
		if we only followed the overall <em>INFO</em> level, appears
		anyway, because it matched the first <code>TurboFilter</code>
		requirements and was accepted.
		</p>    
		
		<p>On the other hand, the 6th request, that is a <em>ERROR</em>
		level request should have been displayed. But it satisfied the
		second <code>TurboFilter</code> whose <span
		class="option">OnMatch</span> option is set to <em>DENY</em>.
		Thus, the 6th request was not displayed.
		</p>
		


		  
    <h3><a name="DuplicateMessageFilter"
    href="#DuplicateMessageFilter">DuplicateMessageFilter</a></h3>

    <p>The <code>DuplicateMessageFilter</code> merits a separate
    presentation.  This filter detects duplicate messages, and beyond
    a certain number of repetitions, drops repeated messages.
    </p>

    <p>To detect repetition, this filter uses simple String equality
    between messages. It does not detect messages which are very
    similar, varying only by few characters. For example, if you
    write:
    </p>

    <p class="source">logger.debug("Hello "+name0);
logger.debug("Hello "+name1);</p>
  
    <p>Assuming <code>name0</code> and <code>name1</code> have
    different values, the two "Hello" messages will be considered as
    unrelated. Depending on user demand, future releases may check for
    string similarity, eliminating repetitions of similar but not
    identical messages.
    </p>

    <p>Note that in case of parameterized logging, only the raw
    message is taken into consideration. For example, in the next two
    requests, the raw messages, i.e. "Hello {}.", are identical, and
    thus considered as repetitions.
    </p>

    <p class="source">logger.debug("Hello {}.", name0);
logger.debug("Hello {}.", name1);</p>
  
    <p>The number of allowed repetitions can be specified by the <span
    class="option">AllowedRepetitions</span> property. For example, if
    the said property is set to 1, then the 2nd and subsequent
    occurrences of the same message will be dropped. Similarly, if the
    said property is set to 2, then the 3rd and subsequent occurrences
    of the same message will be dropped. By default, the <span
    class="option">AllowedRepetitions</span> property is set to 5.
    </p>

    <p>In order to detect repetitions, this filter needs to keep
    references to old messages in an internal cache. The size of this
    cache is determined by the <span class="option">CacheSize</span>
    property. By the default, this is set to 100.
    </p>

    
<em>Example: <code>DuplicateMessageFilter</code> 
configuration (logback-examples/src/main/java/chapter6/duplicateMessage.xml)</em>
<div class="source"><pre>&lt;configuration>

  <b>&lt;turboFilter class="ch.qos.logback.classic.turbo.DuplicateMessageFilter"/></b>

  &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%date [%thread] %-5level %logger - %msg%n&lt;/Pattern>
  &lt;/layout>
  &lt;/appender>

  &lt;root level="info">
    &lt;appender-ref ref="console" />
  &lt;/root>  
&lt;/configuration></pre></div>

  <p>Thus, the output for <code>FilterEvents</code> application
  configured with <em>duplicateMessage.xml</em> is:
  </p>

    <p class="source">2008-12-19 15:04:26,156 [main] INFO  chapter6.FilterEvents - logging statement 0
2008-12-19 15:04:26,156 [main] INFO  chapter6.FilterEvents - logging statement 1
2008-12-19 15:04:26,156 [main] INFO  chapter6.FilterEvents - logging statement 2
2008-12-19 15:04:26,156 [main] INFO  chapter6.FilterEvents - logging statement 4
2008-12-19 15:04:26,156 [main] INFO  chapter6.FilterEvents - logging statement 5
2008-12-19 15:04:26,171 [main] ERROR chapter6.FilterEvents - billing statement 6</p>

    <p>"logging statement 0" is the first <em>occurrence</em> of the
    message "logging statement {}". "logging statement 1" is the first
    <em>repetition</em>, "logging statement 2" is the second
    repetition. Interestingly enough, "logging statement 3" of level
    DEBUG, is the <em>third</em> repetition, even though it is later
    dropped by virtue of the <a
    href="architecture.html#basic_selection">basic selection
    rule</a>. This can be explained by the fact that turbo filters are
    invoked before other types of filters, including the basic
    selection rule. Thus, <code>DuplicateMessageFilter</code>
    considers "logging statement 3" as a repetition, oblivious to the
    fact that it will be dropped further down in the processing
    chain. "logging statement 4" is the fourth repetition and "logging
    statement 5" the fifth. Statements 6 and beyond are dropped
    because only 5 repetitions are allowed by default.
    </p>

    <h2>Logback-access</h2>
    
    <p>Logback-access offers most of the features available with
    logback-classic. <code>Filter</code> objects are available and
    work in the same way as their logback-classic counterparts. They
    handle access' implementation of logging events:
    <code>AccessEvent</code>.  Thus, a customized filter for logback
    access follows strictly the same rules as those for
    logback-classic, except for the event type recieved as parameter.
    On the other hand, <code>TurboFilter</code> objects are supported
    by logback-access.
    </p>
    
    <h3>Filters</h3>
    
    <p><code>EvaluatorFilter</code> objects with java expressions
    supplied in in <code>evaluator</code> configuration elements are
    supported by logback-access. However, list implicit variables
    available for constructing an expression are different. Only the
    <code>AccessEvent</code> object can be used by inserting the
    <em>event</em> variable in the expression. Nevertheless the access
    <code>evaluator</code> is just as powerfull. All the request and
    response components are reachable from the <em>event</em>
    variable.
    </p>    
    
    <p>Here is a sample configuration that will ensure that any 404
    error will be logged:
    </p>
   	
<em>Example 6.9: Access Evaluator (logback-examples/src/main/java/chapter6/accessEventEvaluator.xml)</em>
<div class="source"><pre>&lt;configuration>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator name="myEval">
        &lt;expression>event.getStatusCode() == 404&lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>ACCEPT&lt;/OnMatch>
    &lt;/filter></b>
    &lt;layout class="ch.qos.logback.access.PatternLayout">
      &lt;pattern>
        %h %l %u %t %r %s %b
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;appender-ref ref="STDOUT" />
&lt;/configuration></pre></div>

		<p>We might imagine a slightly more complex use of filters to
		ensure logging of 404 errors, except those returned on access to
		CSS resources. Here is what such a configuration would look like:
		</p>	

    <em>Example 6.10: Access Evaluator (logback-examples/src/main/java/chapter6/accessEventEvaluator2.xml)</em>
    <p class="source">&lt;configuration>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator name="Eval404">
        &lt;expression>event.getStatusCode() == 404&lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>ACCEPT&lt;/OnMatch>
    &lt;/filter>
    &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator name="EvalCSS">
        &lt;expression>event.getRequestURI().contains("css")&lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>DENY&lt;/OnMatch>
    &lt;/filter></b>
    &lt;layout class="ch.qos.logback.access.PatternLayout">
      &lt;pattern>
        %h %l %u %t %r %s %b
      &lt;/pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;appender-ref ref="STDOUT" />
&lt;/configuration>
    </p>
	
    <script src="../templates/footer.js" type="text/javascript"></script>

  </div>
</body>
</html>
