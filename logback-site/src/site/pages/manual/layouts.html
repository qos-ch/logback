<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>Chapter 5: Layouts</title>
  <link rel="stylesheet" type="text/css" href=
  "../css/common.css" />
  <link rel="stylesheet" type="text/css" href="../css/screen.css"
  media="screen" />
  <link rel="stylesheet" type="text/css" href="../css/_print.css"
  media="print" />
  <link rel="stylesheet" type="text/css" href="../css/prettify.css"
  media="screen" />
</head>

<body onload="prettyPrint()">
  <script type="text/javascript">
//<![CDATA[
  prefix='../';
  //]]>
  </script><script type="text/javascript" src="../js/prettify.js">
</script><script src="../templates/header.js" type=
"text/javascript">
</script>

  <div id="left">
    <noscript>Please turn on Javascript to view this
    menu</noscript> <script src="../templates/left.js" type=
    "text/javascript">
</script>
  </div>

  <div id="right">
    <script src="menu.js" type="text/javascript">
</script>
  </div>

  <div id="content">
    <h1>Chapter 5: Layouts</h1>

    <div class="quote">
      <p>TCP implementations will follow a general principle of
      robustness: be conservative in what you do, be liberal in
      what you accept from others.</p>

      <p>&mdash;JON POSTEL, RFC 793</p>
    </div><script src="../templates/creative.js" type=
    "text/javascript">
</script> <script src="../templates/setup.js" type=
"text/javascript">
</script>

    <h2>What is a layout?</h2>

    <p>While appenders are responsible for writing logging output
    to an appender dependent device, layouts are responsible for
    the format of the output. In case you were wondering, layouts
    have nothing to do with large estates in Florida. The
    <code>format()</code> method in the <a href=
    "../xref/ch/qos/logback/core/Layout.html"><code>Layout</code></a>
    interface takes an object that represents an event (of any
    type) and returns a String. A synopsis of the
    <code>Layout</code> interface is shown below.</p>
    <pre class="prettyprint source">
public interface Layout&lt;E&gt; extends ContextAware, LifeCycle {

  String doLayout(E event);
  String getHeader();
  String getFooter();
  String getContentType();
}
</pre>

    <p>This interface is rather simple and yet is sufficent for
    many formatting needs. The Texan developer from Texas, who you
    might know from Joseph Heller's <em>Catch-22</em>, might
    exclaim: it just takes five methods to implement a
    layout!!?</p>

    <h2>Logback-classic</h2>

    <p>Logback-classic is wired to processes only events of type
    <a href=
    "../xref/ch/qos/logback/classic/spi/ILoggingEvent.html"><code>ch.qos.logback.classic.spi.ILoggingEvent</code></a>.
    This fact will be apparent throughout this section.</p>

    <h3>Writing your own Layout</h3>

    <p>Let us implement a simple yet functional layout for the
    logback-classic module that prints the time elapsed since the
    start of the application, the level of the logging event, the
    caller thread between brackets, its logger name, a dash
    followed by the event message and a new line.</p>

    <p>Sample output might look like:</p>

    <div class="source">
      10489 DEBUG [main] com.marsupial.Pouch - Hello world.
    </div>

    <p>Here is a possible implementation, authored by the Texan
    developer:</p><em>Example 5.0: Sample implementation of a
    Layout <a href=
    "../xref/chapter5/MySampleLayout.html">(logback-examples/src/main/java/chapter5/MySampleLayout.java)</a></em>
    <pre class="prettyprint source">
package chapter5;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout extends LayoutBase&lt;ILoggingEvent&gt; {

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    sbuf.append(event.getTimeStamp() - event.getLoggingContextVO.getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    sbuf.append(" [");
    sbuf.append(event.getThreadName());
    sbuf.append("] ");
    sbuf.append(event.getLoggerName();
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(CoreConstants.LINE_SEP);
    return sbuf.toString();
  }
}
</pre>

    <p>Note that <code>MySampleLayout</code> extends <a href=
    "../xref/ch/qos/logback/core/LayoutBase.html"><code>LayoutBase</code></a>.
    This class manages state shared by all <code>Layout</code>
    classes, such as whether the layout is started or stopped,
    header, footer and content type data. It allows the developer
    to concentrate on the formatting expected from his/her
    <code>Layout</code>. Note that the <code>LayoutBase</code>
    class is generic. In its class declaration,
    <code>MySampleLayout</code> extends
    <code>LayoutBase&lt;ILoggingEvent&gt;</code>.</p>

    <p>The <code>doLayout(ILoggingEvent event)</code> method, i.e.
    the only method in <code>MySampleLayout</code>, begins by
    instantiating a <code>StringBuffer</code>. It proceeds by
    adding various fields of the event parameter. The Texan from
    Texas was careful to print the formatted form of the message.
    This is significant in case one or more parameters were passed
    along with the logging request.</p>

    <p>After adding these various characters to the string buffer,
    the <code>doLayout()</code> method converts the buffer into a
    <code>String</code> and returns the resulting value.</p>

    <p>In the above example, the <code>doLayout</code> method
    ignores any eventual exceptions contained in the event. In a
    real world layout implementation, you would most probably want
    to print the contents of exceptions as well.</p>

    <h3>Configuring your custom layout</h3>

    <p>Custom layouts are configured as any other layout. Here is
    as example:</p><em>Example 5.0: Configuration of MySampleLayout
    (logback-examples/src/main/java/chapter5/sampleLayoutConfig.xml)</em>
    <pre class="prettyprint source">
&lt;configuration&gt;

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender"&gt;
    <b>&lt;layout class="chapter5.MySampleLayout" /&gt;</b>
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p>The sample application <a href=
    "../xref/chapter5/SampleLogging.html"><code>chapter5.SampleLogging</code></a>
    configures logback with the configuration script supplied as
    a parameter and then logs a debug message, followed by an error
    message.</p>

    <p>To run this example issue the following command from within
    the <em>logback-examples</em> directory.</p>

    <p class="command">java chapter5.SampleLogging
    src/main/java/chapter5/sampleLayoutConfig.xml</p>

    <p>This will produce:</p>

    <div class="source">
      <pre>
0 DEBUG [main] chapter5.SampleLogging - Everything's going well
0 ERROR [main] chapter5.SampleLogging - maybe not quite...
</pre>
    </div>

    <p>That was simple enough. The skeptic Pyrrho of Elea, who
    insists that nothing is certain except perhaps uncertainty
    itself, which is by no means certain either, might ask: how
    about a layout with options? The reader shall find a slightly
    modified version of our custom layout in
    <code>MySampleLayout2.java</code>. She will discover that
    adding an option to a layout is as simple as declaring a setter
    method for the option.</p>

    <p>The <a href=
    "../xref/chapter5/MySampleLayout2.html"><code>MySampleLayout2</code></a>
    class contains two attributes. The first one is a prefix that
    can be added to the output. The second attribute is used to
    choose whether to display the name of the thread from which the
    logging request was sent.</p>

    <p>Here is the implementation of this class:</p>
    <pre class="prettyprint source">
package chapter5;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout2 extends LayoutBase&lt;ILoggingEvent&gt; {

  String prefix = null;
  boolean printThreadName = true;

  <b>public void setPrefix(String prefix) {
    this.prefix = prefix;
  }

  public void setPrintThreadName(boolean printThreadName) {
    this.printThreadName = printThreadName;
  }</b>

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    <b>if (prefix != null) {
      sbuf.append(prefix + ": ");
    }</b>
    sbuf.append(event.getTimeStamp() - event.getLoggerContextVO().getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    <b>if (printThreadName) {
      sbuf.append(" [");
      sbuf.append(event.getThreadName());
      sbuf.append("] ");
    } else {
      sbuf.append(" ");
    }</b>
    sbuf.append(event.getLoggerName());
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
}
</pre>

    <p>The addition of the corresponding setter method is all that
    is needed to enable the configuration of an option. Note that
    the <code>PrintThreadName</code> option is boolean and not
    <code>String</code>. Configuration of logback components was
    covered in detail in <a href="configuration.html">"Chapter 3:
    Logback configuration"</a>. Here is the configuration file
    tailor-made for use with <code>MySampleLayout2</code>.</p>
    <pre class="prettyprint source">
&lt;configuration&gt;

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;layout class="chapter5.MySampleLayout2"&gt; 
      <b>&lt;prefix&gt;MyPrefix&lt;/prefix&gt;</b>
      <b>&lt;printThreadName&gt;false&lt;/printThreadName&gt;</b>
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <h3><a name="ClassicPatternLayout" href="#ClassicPatternLayout"
    id="ClassicPatternLayout">PatternLayout</a></h3>

    <p>Logback classic ships with a flexible layout called <a href=
    "../xref/ch/qos/logback/classic/PatternLayout.html"><code>PatternLayout</code></a>.
    As all layouts, <code>PatternLayout</code> takes a logging
    event and returns a <code>String</code>. However, this
    <code>String</code> can be customized at will by tweaking the
    conversion pattern of <code>PatternLayout</code>.</p>

    <p>The conversion pattern of <code>PatternLayout</code> is
    closely related to the conversion pattern of the
    <code>printf()</code> function in the C programming language. A
    conversion pattern is composed of literal text and format
    control expressions called conversion specifiers. You are free
    to insert any literal text within the conversion pattern. Each
    conversion specifier starts with a percent sign '%' and is
    followed by optional format modifiers, a conversion word and
    optional parameters between braces. The conversion word
    controls the type of data to use, e.g. logger name, level,
    date, thread name. The format modifiers control such things as
    field width, padding, and left or right justification. The
    following is a simple example.</p><em>Example 5.1: Sample usage
    of a PatternLayout <a href=
    "../xref/chapter5/PatternSample.html">(logback-examples/src/main/java/chapter5/PatternSample.java)</a></em>
    <pre class="prettyprint source">
package chapter5;

import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.PatternLayout;
import ch.qos.logback.core.ConsoleAppender;

public class PatternSample {

  static public void main(String[] args) throws Exception {
    Logger rootLogger = (Logger)LoggerFactory.getLogger("root");

    <b>PatternLayout layout = new PatternLayout();</b>
    <b>layout.setPattern("%-5level [%thread]: %message%n");</b>
    <b>layout.start();</b>

    ConsoleAppender&lt;ILoggingEvent&gt; appender = new ConsoleAppender&lt;ILoggingEvent&gt;();
    appender.setContext(rootLogger.getLoggerContext());
    appender.setLayout(layout); appender.start();

    rootLogger.addAppender(appender);

    rootLogger.debug("Message 1"); 
    rootLogger.warn("Message 2");
  } 
}
</pre>

    <p>The conversion pattern is set to be <b>"%-5level [%thread]:
    %message%n"</b>. Running PatternSample will yield the following
    output on the console.</p>

    <p class="source">DEBUG [main]: Message 1 WARN [main]: Message
    2</p>

    <p>Note that in the conversion pattern <b>"%-5level [%thread]:
    %message%n"</b> there is no explicit separator between literal
    text and conversion specifiers. When parsing a conversion
    pattern, <code>PatternLayout</code> is capable of
    differentiating between literal text (space characters, the
    brackets, colon character) and conversion specifiers. In the
    example above, the conversion specifier %-5level means the
    level of the logging event should be left justified to a width
    of five characters. Format specifiers are explained below.</p>

    <p>In PatternLayout, parenthesis can be used to group
    conversion patterns. <b>It follows that the '(' and ')' carry
    special meaning and need to be escaped to be used as
    literals.</b> Parentheses can be escaped by preceding the the
    opening and closing parenthesis by a backslash, but since
    the backslash itself carries special meaning in Java, we need two
    backslashes, as in "\\(" and "\\)". Note that strictly
    speaking, only the closing parenthesis needs to be escaped to
    be used as a literal.</p>

    <p>As mentioned previously, certain conversion specifiers can
    include optional parameters which are passed between braces
    following the conversion word. A sample conversion specifier
    with options could be <code>%logger{10}</code>. Here "logger"
    is the conversion word, and 10 is the option.</p>

    <p>The recognized conversions words along with their options
    are described in the table below. When multiple conversion
    words are listed on the left column, they should be considered
    as aliases.</p>

    <table class="bodyTable properties" border="0">
      <tr>
        <th><a name="conversionWord" href="#conversionWord" id=
        "conversionWord">Conversion Word</a></th>

        <th>Effect</th>
      </tr>

      <tr>
        <td align="center"><b>c</b>{<em>length</em>}<br />
        <b>lo</b>{<em>length</em>}<br />
        <b>logger</b>{<em>length</em>}<br /></td>

        <td>
          <p>Used to output the name of the logger at the origin of
          the logging event.</p>

          <p>This conversion word can take an integer as its first
          and only option. The converter's abbreviation algorithm
          will shorten the logger name, usually without significant
          loss of meaning. Setting the value of this option to zero
          has special meaning. It will cause the conversion
          specifier to return the string right of the rightmost dot
          character. The next table provides examples of the
          abbreviation algorithm in action.</p>

          <table class="bodyTable dark" border="0" cellpadding="8">
            <tr>
              <th>Conversion specifier</th>

              <th>Logger name</th>

              <th>Result</th>
            </tr>

            <tr>
              <td>%logger</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>mainPackage.sub.sample.Bar</td>
            </tr>

            <tr>
              <td>%logger{0}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>Bar</td>
            </tr>

            <tr>
              <td>%logger{5}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>m.s.s.Bar</td>
            </tr>

            <tr>
              <td>%logger{10}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>m.s.s.Bar</td>
            </tr>

            <tr>
              <td>%logger{15}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>m.s.sample.Bar</td>
            </tr>

            <tr>
              <td>%logger{16}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>m.sub.sample.Bar</td>
            </tr>

            <tr>
              <td>%logger{26}</td>

              <td>mainPackage.sub.sample.Bar</td>

              <td>mainPackage.sub.sample.Bar</td>
            </tr>
          </table>

          <p>Please note that the rightmost segment in a logger
          name is never abbreviated, even if its length is longer
          than the <em>length</em> option. Other segments may be
          shortened to at most a single character but are never
          removed.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>C</b>{<em>length</em>}<br />
        <b>class</b>{<em>length</em>}<br /></td>

        <td>
          <p>Used to output the fully-qualified class name of the
          caller issuing the logging request.</p>

          <p>Just like the <em>%logger</em> conversion word above,
          this word can take an integer as its first option and
          use its abbreviation algorithm to shorten the class name.
          Zero carries special meaning and will cause the simple
          class name to be printed without its package name prefix.
          By default the class name is printed in full.</p>

          <p>Generating the caller class information is not
          particularly fast. Thus, its use should be avoided
          unless execution speed is not an issue.</p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>contextName</b><br />
        <b>cn</b><br /></td>

        <td>Outputs the name of the logger context to which the
        logger at the origin of the logging event is attached
        to.</td>
      </tr>

      <tr class="alt">
        <td align="center"><b>d</b>{<em>pattern</em>}<br />
        <b>date</b>{<em>pattern</em>}<br /></td>

        <td>
          <p>Used to output the date of the logging event. The date
          conversion word may be followed by an option enclosed
          between braces.</p>

          <p>The option admits the same syntax as the time pattern
          string of the
          <code>java.text.SimpleDateFormat</code>.</p>

          <p>A shortcut to the ISO8601 format is available by
          specifying the String <em>"ISO8601"</em> in the braces.
          If no option is set, the converter uses
          <em>"ISO8601"</em> as the default value.</p>

          <p>Here are some sample option values. They assume that
          the actual date is Friday 20th of October, 2006 and that
          the author finished his meal a short while ago.</p>

          <table class="bodyTable dark" cellpadding="8">
            <tr>
              <th>Conversion Pattern</th>

              <th>Result</th>
            </tr>

            <tr>
              <td>%date</td>

              <td>2006-10-20 14:46:49,812</td>
            </tr>

            <tr>
              <td>%date{ISO8601}</td>

              <td>2006-10-20 14:46:49,812</td>
            </tr>

            <tr>
              <td>%date{HH:mm:ss.SSS}</td>

              <td>14:46:49.812</td>
            </tr>

            <tr>
              <td>
              %date{dd&nbsp;MMM&nbsp;yyyy&nbsp;;HH:mm:ss.SSS}</td>

              <td>20 oct. 2006;14:46:49.812</td>
            </tr>
          </table>
        </td>
      </tr>

      <tr>
        <td align="center"><b>F / file</b></td>

        <td>
          <p>Used to output the file name of the Java source file
          where the logging request was issued.</p>

          <p>Generating the file information is not particularly
          fast. Thus, its use should be avoided unless execution
          speed is not an issue.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>caller{depth}</b> <b>caller{depth,
        evaluator-1, ... evaluator-n}</b></td>

        <td>
          <p>Used to output location information of the caller
          which generated the logging event.</p>

          <p>The location information depends on the JVM
          implementation but usually consists of the fully
          qualified name of the calling method followed by the
	  caller's source, the file name and line number between
          parentheses.</p>

          <p>A integer can be added to the <em>caller</em>
          conversion specifier's options to configure the depth of
          the information to be displayed.</p>

          <p>For example, <b>%caller{2}</b> would display the
          following excerpt:</p>

          <div class="source white_bg">
            <pre>
0    [main] DEBUG - logging statement 
Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)
</pre>
          </div>

          <p>And <b>%caller{3}</b> would display this other
          excerpt:</p>

          <div class="source white_bg">
	    <pre>
16 [main] DEBUG - logging statement
Caller+0 at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1 at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)
Caller+2 at mainPackage.ConfigTester.main(ConfigTester.java:38)
	    </pre>
          </div>

          <p>This conversion word can also use evaluators to test
          logging events against a given criterion before creating
          the output. For example, using <b>%caller{3,
          CALLER_DISPLAY_EVAL}</b> will display three lines of
          stack trace, only if the evaluator called
          <em>CALLER_DISPLAY_EVAL</em> returns a <b>positive</b>
          answer.</p>

          <p>Evaluators are described below.</p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>L / line</b></td>

        <td>
          <p>Used to output the line number from where the logging
          request was issued.</p>

          <p>Generating the line number information is not
          particularly fast. Thus, its use should be avoided
          unless execution speed is not an issue.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>m / msg / message</b></td>

        <td>Used to output the application-supplied message
        associated with the logging event.</td>
      </tr>

      <tr>
        <td align="center"><b>M / method</b></td>

        <td>
          <p>Used to output the method name where the logging
          request was issued.</p>

          <p>Generating the method name is not particularly fast.
          Thus, its use should be avoided unless execution speed
          is not an issue.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>n</b></td>

        <td>
          <p>Outputs the platform dependent line separator
          character or characters.</p>

          <p>This conversion word offers practically the same
          performance as using non-portable line separator strings
          such as "\n", or "\r\n". Thus, it is the preferred way of
          specifying a line separator.</p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>p / le / level</b></td>

        <td>Used to output the level of the logging event.</td>
      </tr>

      <tr class="alt">
        <td align="center"><b>r / relative</b></td>

        <td>Used to output the number of milliseconds elapsed since
        the start of the application until the creation of the
        logging event.</td>
      </tr>

      <tr>
        <td align="center"><b>t / thread</b></td>

        <td>Used to output the name of the thread that generated
        the logging event.</td>
      </tr>

      <tr class="alt">
        <td align="center"><b>X</b>{<em>key</em>}<br />
        <b>mdc</b>{<em>key</em>}<br /></td>

        <td>
          <p>Used to output the MDC (mapped diagnostic context)
          associated with the thread that generated the logging
          event.</p>

          <p>If <b>mdc</b> conversion word is followed by a key
          between braces, as in <b>%mdc{clientNumber}</b>, then the
          value in the MDC corresponding to the key will be
          output.</p>

          <p>If no option is given, then the entire content of the
          MDC will be output in the format "key1=val1,
          key2=val2".</p>

          <p>See <a href="mdc.html">Chapter 7</a> for more details
          on the MDC.</p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>ex</b>{<em>length</em>}<br />
        <b>exception</b>{<em>length</em>}<br />
        <b>throwable</b>{<em>length</em>}<br />
        <br />
        <b>ex</b>{length, evaluator-1, ..., evaluator-n}<br />
        <b>exception</b>{length, evaluator-1, ...,
        evaluator-n}<br />
        <b>throwable</b>{length, evaluator-1, ...,
        evaluator-n}</td>

        <td>
          <p>Used to output the stack trace of the exception
          associated with the logging event, if any. By default the
          full stack trace will be output.</p>

          <p>If you do not specify the %ex conversion word (or one
          of its aliases) in the conversion pattern,
          <code>PatternLayout</code> will automatically add it as
          the last conversion word, on account of the importance of
          stack trace information. The $nopex conversion word can
          be substituted for %ex, in case you do not wish stack
          trace information to be displayed. See also %nopex
          conversion word.</p>

          <p>The <em>throwable</em> conversion word can followed by
          one of the following options:</p>

          <ul>
            <li><em>short</em>: prints the first line of the stack
            trace</li>

            <li><em>full</em>: prints the full stack trace</li>

            <li>Any integer: prints the given number of lines of
            the stack trace</li>
          </ul>

          <p>Here are some examples:</p>

          <table class="bodyTable">
            <tr class="a">
              <th>Conversion Pattern</th>

              <th>Result</th>
            </tr>

            <tr class="b">
              <td>%ex</td>

              <td>
                <pre>
mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)
</pre>
              </td>
            </tr>

            <tr class="a">
              <td>%ex{short}</td>

              <td>
                <pre>
mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
</pre>
              </td>
            </tr>

            <tr class="b">
              <td>%ex{full}</td>

              <td>
                <pre>
mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)
</pre>
              </td>
            </tr>

            <tr class="a">
              <td>%ex{2}</td>

              <td>
                <pre>
mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
</pre>
              </td>
            </tr>
          </table>

          <p>This conversion word can also use evaluators to test
          logging events against a given criterion before creating
          the output. For example, using <b>%ex{full,
          EX_DISPLAY_EVAL}</b> will display the full stack trace of
          the exception, only if the evaluator called
          <em>EX_DISPLAY_EVAL</em> returns a <b>negative</b>
          answer. Evaluators are described further down in this
          document.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>xEx</b>{<em>length</em>}<br />
        <b>xException</b>{<em>length</em>}<br />
        <b>xThrowable</b>{<em>length</em>}<br />
        <br />
        <b>xEx</b>{length, evaluator-1, ..., evaluator-n}<br />
        <b>xException</b>{length, evaluator-1, ...,
        evaluator-n}<br />
        <b>xThrowable</b>{length, evaluator-1, ...,
        evaluator-n}</td>

        <td>
          <p>Same as the %exception conversion keyword with the
          addition of class packaging information.</p>

          <p>At the end of each stack frame of the exception, a
          string consisting of the jar file containing the relevant
          class followed by the "Implementation-Version" as found
          in that jar's manifest will be added. This innovative
          technique was <a href=
          "http://macstrac.blogspot.com/2008/09/better-stack-traces-in-java-with-log4j.html">
          suggested by James Strachan</a>. If the information is
          uncertain, then the class packaging data will be preceded
          by a tilde, i.e. the '~' character.</p>

          <p>Here is an example:</p>

          <p class="source small">java.lang.NullPointerException at
          com.xyz.Wombat(Wombat.java:57) <b><span class=
          "red">~</span>[wombat-1.3.jar:1.3]</b> at
          com.xyz.Wombat(Wombat.java:76) ~[wombat-1.3.jar:1.3] at
          sun.reflect.NativeMethodAccessorImpl.invoke0(Native
          Method) ~[na:1.5.0_06] at
          sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
          ~[na:1.5.0_06] at
          sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
          ~[na:1.5.0_06] at
          java.lang.reflect.Method.invoke(Method.java:585)
          ~[na:1.5.0_06] at
          org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59)
          [junit-4.4.jar:na] at
          org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98)
          [junit-4.4.jar:na] ...etc</p>

          <p>Logback goes to great lengths to ensure that the class
          packaging information it displays is correct, even in
          arbirarily complex classloader hierarchies. However,
          when it is not able to guarantee the absolute correctness
          of the information, then it will prefix the data with a
          tilde, i.e. the '~' character. Thus, it is theoretically
          possible for the printed class packaging information to
          differ from the real class packaging information. So, in
          the above example, given that packaging data for the
          Wombat class is preceded by a tilde, it possible that the
          correct packaging data is in reality
          [wombat.jar:1.7].</p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>nopex</b><br />
        <b>nopexception</b></td>

        <td>
          <p>Altough it pretends to handle stack trace data, this
          conversion word does not output any data, thus,
          effectively ignoring exceptions.</p>

          <p>The %nopex conversion word allows the user to override
          PatternLayout's internal safety mechanism which silently
          adds %ex conversion keyword, even it was not specified in
          the conversion pattern.</p>
        </td>
      </tr>

      <tr class="alt">
        <td align="center"><b>marker</b></td>

        <td>
          <p>Used to output the marker associated with the logger
          request.</p>

          <p>In case the marker contains children markers, the
          converter displays the parent as well as childrens' names
          according to the format shown below.</p>

          <p><em>parentName [ child1, child2 ]</em></p>
        </td>
      </tr>

      <tr>
        <td align="center"><b>property{key}</b></td>

        <td>
          <p>Used to output the value associated with a context
          property named <em>key</em>. If <em>key</em> is not a
          property of the logger context, then <em>key</em> will be
          looked up in the System properties.</p>

          <p>There is no default value for <em>key</em>. If it is
          omitted, the returned value will be
          "Property_HAS_NO_KEY", expliciting the error
          condition.</p>
        </td>
      </tr>
    </table>

    <p>Given that in the context of conversion patterns the percent
    sign carries special meaning, in order to include it as a
    literal, it needs to be escaped with a backslash, e.g. "%d %p
    <b>\%</b> %m%n".</p>

    <h2>Format modifiers</h2>

    <p>By default the relevant information is output as is.
    However, with the aid of format modifiers it is possible to
    change the minimum field width, the maximum field width as well
    as justification.</p>

    <p>The optional format modifier is placed between the percent
    sign and the conversion character or word.</p>

    <p>The first optional format modifier is the <em>left
    justification flag</em> which is just the minus (-) character.
    Then comes the optional <em>minimum field width</em> modifier.
    This is a decimal constant that represents the minimum number
    of characters to output. If the data item contains fewer
    characters, it is padded on either the left or the right until
    the minimum width is reached. The default is to pad on the left
    (right justify) but you can specify right padding with the left
    justification flag. The padding character is space. If the data
    item is larger than the minimum field width, the field is
    expanded to accommodate the data. The value is never
    truncated.</p>

    <p>This behavior can be changed using the <em>maximum field
    width</em> modifier which is designated by a period followed by
    a decimal constant. If the data item is longer than the maximum
    field, then the extra characters are removed from the
    <em>beginning</em> of the data item. For example, if the
    maximum field width is eight and the data item is ten
    characters long, then the first two characters of the data item
    are dropped. This behavior deviates from the printf function in
    C where truncation is done from the end.</p>

    <p>Truncation from the end is possible by appending a minus
    character right after the period. In that case, if the maximum
    field width is eight and the data item is ten characters long,
    then the last two characters of the data item are dropped.</p>

    <p>Below are various format modifier examples for the logger
    conversion specifier.</p>

    <table class="bodyTable" border="0" cellpadding="8">
      <tr>
        <th>Format modifier</th>

        <th>Left justify</th>

        <th>Minimum width</th>

        <th>Maximum width</th>

        <th>Comment</th>
      </tr>

      <tr class="a">
        <td align="center">%20logger</td>

        <td align="center">false</td>

        <td align="center">20</td>

        <td align="center">none</td>

        <td>Left pad with spaces if the logger name is less than 20
        characters long.</td>
      </tr>

      <tr class="b">
        <td align="center">%-20logger</td>

        <td align="center">true</td>

        <td align="center">20</td>

        <td align="center">none</td>

        <td>Right pad with spaces if the logger name is less than
        20 characters long.</td>
      </tr>

      <tr class="a">
        <td align="center">%.30logger</td>

        <td align="center">NA</td>

        <td align="center">none</td>

        <td align="center">30</td>

        <td>Truncate from the beginning if the logger name is
        longer than 30 characters.</td>
      </tr>

      <tr class="b">
        <td align="center">%20.30logger</td>

        <td align="center">false</td>

        <td align="center">20</td>

        <td align="center">30</td>

        <td>Left pad with spaces if the logger name is shorter than
        20 characters. However, if logger name is longer than 30
        characters, then truncate from the beginning.</td>
      </tr>

      <tr class="a">
        <td align="center">%-20.30logger</td>

        <td align="center">true</td>

        <td align="center">20</td>

        <td align="center">30</td>

        <td>Right pad with spaces if the logger name is shorter
        than 20 characters. However, if logger name is longer than
        30 characters, then truncate from the
        <em>beginning</em>.</td>
      </tr>

      <tr class="b">
        <td align="center">%.-30logger</td>

        <td align="center">NA</td>

        <td align="center">none</td>

        <td align="center">30</td>

        <td>Truncate from the <em>end</em> if the logger name is
        longer than 30 characters.</td>
      </tr>
    </table>

    <p>The table below list examples for format modifier
    truncation. Please note that the brackets, i.e the pair of "[]"
    characters, are not part of the output. They are used to
    delimit the width of output.</p>

    <table class="bodyTable" border="0" cellpadding="8">
      <tr>
        <th>Format modifier</th>

        <th>Logger name</th>

        <th>Result</th>
      </tr>

      <tr class="b">
        <td align="center">[%20.20logger]</td>

        <td align="center">main.Name</td>

        <td align="center">
          <pre>
[           main.Name]
</pre>
        </td>
      </tr>

      <tr class="a">
        <td align="center">[%-20.20logger]</td>

        <td align="center">main.Name</td>

        <td align="center">
          <pre>
[main.Name           ]
</pre>
        </td>
      </tr>

      <tr class="a">
        <td align="center">[%10.10logger]</td>

        <td align="center">main.foo.foo.bar.Name</td>

        <td align="center">
          <pre>
[o.bar.Name]
</pre>
        </td>
      </tr>

      <tr class="b">
        <td align="center">[%10.-10logger]</td>

        <td align="center">main.foo.foo.bar.Name</td>

        <td align="center">
          <pre>
[main.foo.f]
</pre>
        </td>
      </tr>
    </table>

    <h3>Parentheses are special</h3>

    <p>In logback, parentheses within the pattern string are
    treated as grouping tokens. Thus, it is possible to group a
    sub-pattern and apply formatting directives on that
    sub-pattern.</p>

    <p>For example, the pattern</p>

    <p class="source"><b>%-30(</b>%d{HH:mm:ss.SSS}
    [%thread]<b>)</b> %-5level %logger{32} - %msg%n</p>

    <p>will group the output generated by the sub-pattern
    "%d{HH:mm:ss.SSS} [%thread]" so that it is right-padded if less
    than 30 characters.</p>

    <p>If without the grouping the output was</p>

    <p class="source">13:09:30 [main] DEBUG
    c.q.logback.demo.ContextListener - Classload hashcode is
    13995234 13:09:30 [main] DEBUG c.q.logback.demo.ContextListener
    - Initializing for ServletContext 13:09:30 [main] DEBUG
    c.q.logback.demo.ContextListener - Trying platform Mbean server
    13:09:30 [pool-1-thread-1] INFO ch.qos.logback.demo.LoggingTask
    - Howdydy-diddly-ho - 0 13:09:38 [btpool0-7] INFO
    c.q.l.demo.lottery.LotteryAction - Number: 50 was tried.
    13:09:40 [btpool0-7] INFO c.q.l.d.prime.NumberCruncherImpl -
    Beginning to factor. 13:09:40 [btpool0-7] DEBUG
    c.q.l.d.prime.NumberCruncherImpl - Trying 2 as a factor.
    13:09:40 [btpool0-7] INFO c.q.l.d.prime.NumberCruncherImpl -
    Found factor 2</p>

    <p>with the "%-30()" grouping it would be</p>

    <p class="source">13:09:30 [main] DEBUG
    c.q.logback.demo.ContextListener - Classload hashcode is
    13995234 13:09:30 [main] DEBUG c.q.logback.demo.ContextListener
    - Initializing for ServletContext 13:09:30 [main] DEBUG
    c.q.logback.demo.ContextListener - Trying platform Mbean server
    13:09:30 [pool-1-thread-1] INFO ch.qos.logback.demo.LoggingTask
    - Howdydy-diddly-ho - 0 13:09:38 [btpool0-7] INFO
    c.q.l.demo.lottery.LotteryAction - Number: 50 was tried.
    13:09:40 [btpool0-7] INFO c.q.l.d.prime.NumberCruncherImpl -
    Beginning to factor. 13:09:40 [btpool0-7] DEBUG
    c.q.l.d.prime.NumberCruncherImpl - Trying 2 as a factor.
    13:09:40 [btpool0-7] INFO c.q.l.d.prime.NumberCruncherImpl -
    Found factor 2</p>

    <p>The latter form is more comfortable to read, especially for
    long log files.</p>

    <p>If you need to treat the parenthesis character as a literal,
    they needs to be escaped by preceding each parenthesis with a
    backslash. As in, <b>\(</b>%d{HH:mm:ss.SSS} [%thread]<b>\)</b>.
    Strictly speaking, only the closing parentesis needs to be
    escaped. Thus, "%d&nbsp;[%thread]<b>\)</b>" is equivalent to
    "<b>\(</b>%d&nbsp;[%thread]<b>\)</b>".</p>

    <h3>Options</h3>

    <p>A conversion specifier can be followed by options. The are
    always declared between braces. We have already seen some of
    the possibilities offered by options, for instance in
    conjunction with the MDC conversion specifier, as in:
    <em>%mdc{someKey}</em>.</p>

    <p>A conversion specifier might have more than one option. For
    example, a conversion specifier that makes use of evaluators,
    which will be covered soon, may add evaluator names to the
    option list, as shown below:</p>
    <pre class="prettyprint source">
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; 
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; 
      &lt;param name="Pattern" value="%-4relative [%thread] %-5level - %msg%n \
        <b>%caller{2, DISP_CALLER_EVAL, OTHER_EVAL_NAME, THIRD_EVAL_NAME}</b>" /&gt; 
    &lt;/layout&gt;
  &lt;/appender&gt;
</pre>

    <h3>Evaluators</h3>

    <p>As mentioned above, option lists come in handy when a
    conversion specifier is required to behave dynamically based on
    one or more <a href=
    "../xref/ch/qos/logback/core/boolex/EventEvaluator.html"><code>EventEvaluator</code></a>
    objects. <code>EventEvaluator</code> objects have the
    responsibility to determine whether a given logging event
    matches the criteria of the evaluator.</p>

    <p>Let us review an example with <code>EventEvaluator</code>
    objects. The following configuration file outputs the logging
    events to the console, displaying date, thread, level, message
    and caller data. Given that extracting the caller data of a
    logging event is on expensive side, we will do so only when the
    logging request originates from a specific logger, and whose
    message contains a certain string. Thus, we make sure that only
    specific logging requests will have their caller information
    generated and displayed. In other cases, where the caller data
    is superfluous, we will not penalize application
    performance.</p><em>Example 5.2: Sample usage of
    EventEvaluators
    (logback-examples/src/main/java/chapter5/callerEvaluatorConfig.xml)</em>
    <pre class="prettyprint source">
&lt;configuration&gt;
  <b>&lt;evaluator name="DISP_CALLER_EVAL"&gt;
    &lt;Expression&gt;logger.getName().contains("chapter5") &amp;amp;&amp;amp; \
      message.contains("who calls thee")&lt;/Expression&gt;
  &lt;/evaluator&gt;</b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; 
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; 
      &lt;Pattern&gt;%-4relative [%thread] %-5level - %msg%n<b>%caller{2, DISP_CALLER_EVAL}</b>
      &lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt; 
    &lt;appender-ref ref="STDOUT" /&gt; 
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p>Due to XML encoding rules, the &amp; character cannot be
    written as is, and needs to be escaped as &amp;amp;.</p>

    <p>The above configuration file is designed to be accompanied
    by the following custom-tailored code.</p>

    <p><em>Example 5.2: Sample usage of EventEvaluators <a href=
    "../xref/chapter5/CallerEvaluatorExample.html">(logback-examples/src/main/java/chapter5/CallerEvaluatorExample.java)</a></em></p>
    <pre class="prettyprint source">
package chapter5;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class CallerEvaluatorExample {

  public static void main(String[] args)  {
    Logger logger = LoggerFactory.getLogger(CallerEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      StatusPrinter.print(lc);
    }

    for (int i = 0; i &lt; 5; i++) {
      if (i == 3) {
        logger.debug("who calls thee?");
      } else {
        logger.debug("I know me " + i);
      }
    }
  }
}
</pre>

    <p>The <em>CallerEvaluatorExample</em> application does nothing
    particularly fancy. Five logging requests are issued, the third
    one being different from the others.</p>

    <p>When a logging request is issued, the corresponding logging
    event goes through the evaluation process. The third request
    matches the evaluation criteria, causing its caller data to be
    displayed.</p>

    <p>Here is the output of the
    <code>CallerEvaluatorExample</code> class.</p>

    <div class="source">
      <pre>
0    [main] DEBUG - I know me 0 
0    [main] DEBUG - I know me 1 
0    [main] DEBUG - I know me 2 
0    [main] DEBUG - who calls thee? 
Caller+0   at chapter5.CallerEvaluatorExample.main(CallerEvaluatorExample.java:28)
0    [main] DEBUG - I know me 4
</pre>
    </div>

    <p>One can change the expression to correspond a real world
    scenario. For instance, one could combine the logger name and
    request level. Thus, logging requests of level <em>WARN</em>
    and up, originating from a sensitive part of an application,
    e.g. a financial transaction module, would have their caller
    data displayed.</p>

    <p><b>Important:</b> With the <em>caller</em> conversion
    specifier, the data is displayed when <em>the expression
    evaluates to <b>true</b>.</em></p>

    <p>Let us consider at a different situation. When exceptions
    are included in a logging request, their stack trace is usually
    displayed. However, in some cases, one might want to supress
    the stack trace of some specific exception.</p>

    <p>The java code shown below creates five log requests, each
    with an exception. However, it so happends that we do not wish
    the stack trace of the third request to be output.</p>

    <p><em>Example 5.2: Sample usage of EventEvaluators <a href=
    "../xref/chapter5/ExceptionEvaluatorExample.html">(logback-examples/src/main/java/chapter5/ExceptionEvaluatorExample.java)</a></em></p>
    <pre class="prettyprint source">
package chapter5;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class ExceptionEvaluatorExample {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(ExceptionEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      StatusPrinter.print(lc);
    }
    for (int i = 0; i &lt; 5; i++) {
      if (i == 3) {
        logger.debug("logging statement " + i, new TestException(
            "do not display this"));
      } else {
        logger.debug("logging statement " + i, new Exception("display"));
      }
    }
  }
}
</pre>

    <p>The following configuration will supress the stack trace of
    the third logging request.</p><em>Example 5.3: Sample usage of
    EventEvaluators
    (logback-examples/src/main/java/chapter5/exceptionEvaluatorConfig.xml)</em>
    <pre class="prettyprint source">
&lt;configuration&gt;

  <b>&lt;evaluator name="DISPLAY_EX_EVAL"&gt;
    &lt;Expression&gt;throwable != null &amp;amp;&amp;amp; throwable instanceof  \
      chapter5.TestException&lt;/Expression&gt;
  &lt;/evaluator&gt;</b>
        
  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;Pattern&gt;%-4relative [%thread] %-5level - %msg%n<b>%ex{full, DISPLAY_EX_EVAL}</b>
      &lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p>With this configuration, each time an instance of the
    <em>chapter5.TestException</em> is included within a logging
    request, the stack trace will be suppressed.</p>

    <p><b>Important:</b> With the <b><em>%ex</em></b> conversion
    specifier, the stack trace is displayed when <em>the expression
    evaluates to <b>false</b>.</em></p>

    <h3><a name="customConversionSpecifier" href=
    "#customConversionSpecifier" id=
    "customConversionSpecifier">Creating a custom conversion
    specifier</a></h3>

    <p>Up to this point we have presented the built-inconversion
    specifiers of <code>PatternLayout</code>. But it is also
    possible to use a conversion specifier of your own making.</p>

    <p>Building a custom conversion specifier consists of two
    steps.</p>

    <p>First, you must extend the <code>ClassicConverter</code>
    class. <a href=
    "../xref/ch/qos/logback/classic/pattern/ClassicConverter.html"><code>
    ClassicConverter</code></a> objects are responsible for
    extracting information out of <code>ILoggingEvent</code>
    instances and producing a String. For example, the <a href=
    "../xref/ch/qos/logback/classic/pattern/LoggerConverter.html"><code>
    LoggerConverter</code></a>, the converter underlying the
    %logger conversion word, extracts the name of the logger from
    <code>ILoggingEvent</code> and returns it as a String. It might
    abbreviate the logger name in the process.</p>

    <p>Let us say that our customized <code>ClassicConverter</code>
    colors the level of the logging event, according to ANSI
    terminal conventions. Here is a possible
    implementation:</p><em>Example 5.4: Sample Converter Example
    <a href=
    "../xref/chapter5/MySampleConverter.html">(src/main/java/chapter5/MySampleConverter.java)</a></em>
    <pre class="prettyprint source">
package chapter5;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.pattern.ClassicConverter;
import ch.qos.logback.classic.spi.ILoggingEvent;

public class MySampleConverter extends ClassicConverter {

  private static final String END_COLOR = "\u001b[m";

  private static final String ERROR_COLOR = "\u001b[0;31m";
  private static final String WARN_COLOR = "\u001b[0;33m";

  @Override
  <b>public String convert(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(getColor(event.getLevel()));
    sbuf.append(event.getLevel());
    sbuf.append(END_COLOR);
    return sbuf.toString();
  }</b>

  /**
   * Returns the appropriate characters to change the color for the specified
   * logging level.
   */
  private String getColor(Level level) {
    switch (level.toInt()) {
    case Level.ERROR_INT:
      return ERROR_COLOR;
    case Level.WARN_INT:
      return WARN_COLOR;
    default:
      return "";
    }
  }
}
</pre>

    <p>This implementation is relatively straightforward. The
    <code>MySampleConverter</code> class extends
    <code>ClassicConverter</code>, and implements the
    <code>convert</code> method where it returns a level string
    decorated with ANSI coloring codes.</p>

    <p>In the second step, we must let logback know about the new
    <code>Converter</code>. For this purpose, we need to declare
    the new conversion word in the configuration file, as shown
    below:</p><em>Example 5.4: Sample Converter Example
    (src/main/java/chapter5/mySampleConverterConfig.xml)</em>
    <pre class="prettyprint source">
&lt;configuration&gt;

  <b>&lt;conversionRule conversionWord="sample" converterClass="chapter5.MySampleConverter" /&gt;</b>
        
  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      <b>&lt;Pattern&gt;%-4relative [%thread] %sample - %msg%n&lt;/Pattern&gt;</b>
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p>In this configuration file, once the new conversion word has
    been declared, we can refert to it within a
    <code>PatternLayout</code> pattern, as if the custom conversion
    word had always been here.</p>

    <p>Given that ANSI terminal codes do not work on Windows, you
    can view the results on non-Windows platforms such as Linux or
    Mac. The following command:</p>

    <div class="source">
      java chapter5.SampleLogging
      src/main/java/chapter5/mySampleConverterConfig.xml
    </div>

    <p>should yield:</p>

    <p class="source">0 [main] DEBUG - Everything's going well 3
    [main] <span class="red">ERROR</span> - maybe not quite...</p>

    <p>Please note that the string "ERROR" is highlighted in red,
    which was somewhat the point of the exercise.</p>

    <p>The intersted reader might want to take a look at other
    <code>Converter</code> implementations such as <a href=
    "../xref/ch/qos/logback/classic/pattern/MDCConverter.html"><code>
    MDCConverter</code></a> to learn about more complex behaviours,
    such as option handling.</p>

    <h3><a name="ClassicHTMLLayout" href="#ClassicHTMLLayout" id=
    "ClassicHTMLLayout">HTMLLayout</a></h3>

    <p><a href=
    "../xref/ch/qos/logback/classic/html/HTMLLayout.html"><code>HTMLLayout</code></a>
    (as included in logback-classic) generates logs in HTML format.
    <code>HTMLLayout</code> outputs logging events in an HTML table
    where each row of the table corresponds to a logging event.</p>

    <p>Here is a sample output produced by <code>HTMLLayout</code>
    using its default CSS stylesheet:</p><img src=
    "images/htmlLayout0.gif" alt="HTML Layout Sample Image" />

    <p>The content of table columns are specified with the help of
    a conversion pattern. See <a href=
    "#ClassicPatternLayout"><code>PatternLayout</code></a> for
    documentation on conversion patterns. As such, you have full
    control over the contents and format of the table. You can
    select and display any combination of converters
    <code>PatternLayout</code> knows about.</p>

    <p>One notable exception about the use of
    <code>PatternLayout</code> with <code>HTMLLayout</code> is that
    conversion specifiers should not be separated by space
    characters or more generally by literal text. Each specifier
    found in the pattern will result in a separate column. Likewise
    a separate column will be generated for each block of literal
    text found in the pattern potentially wasting valuable real
    estate on your screen.</p>

    <p>Here is simple but functional configuration file
    illustrating the use of <code>HTMLLayout</code>.</p>
    <pre class="prettyprint source">
&lt;configuration debug="true"&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
      <b>&lt;pattern&gt;%relative%thread%mdc%level%logger%msg&lt;/pattern&gt;</b>
    &lt;/layout&gt;
   &lt;File&gt;/test.html&lt;/File&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p>Launching the <code>TrivialMain</code> application listed
    below will create the file <em>test.html</em> on your local
    drive.</p>
    <pre class="prettyprint source">
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TrivialMain {
  public static void main(String[] args) throws InterruptedException {
    Logger logger = LoggerFactory.getLogger(TrivialMain.class);
    for(int i = 0; i &lt; 6; i ++) {
      if(i % 5 == 0) {
        logger.info("an info message "+i);
      } else {
        logger.debug("hello world number" +i);
      }
    }
    logger.error("Finish off with fireworks", new Exception("Just testing"));
  }
}
</pre>

    <p>The contents of <em>test.html</em> should be similar
    to:</p><img src="images/htmlLayout1.jpg" alt=
    "HTML Layout Sample Image" />

    <h3>Stack traces</h3>

    <p>If you use the <em>%em</em> conversion word to display stack
    traces, a table column will be created to display stack traces.
    In most cases the column will be empty, wasting screen
    real-estate. Moreover, printing a stack trace on a separate
    column does not yield very readable results. Fortunately, the
    <em>%ex</em> conversion word is not the only way to display
    stack traces.</p>

    <p>A better solution is available through implementations of
    <code>IThrowableRenderer</code> interface. Such an
    implementation can be assigned to <code>HTMLLayout</code> to
    manage the display data related to exceptions. By default, a
    <a href=
    "../xref/ch/qos/logback/classic/html/DefaultThrowableRenderer.html">
    <code>DefaultThrowableRenderer</code></a> is assigned to each
    <code>HTMLLayout</code> instance. It writes exceptions on a
    <em>new table row</em>, along with its stack trace, in an easily
    readable manner, as shown on the figure above.</p>

    <p>If for some reason, you still wish to use the <em>%ex</em>
    pattern, then you can specify <a href=
    "../xref/ch/qos/logback/core/html/NOPThrowableRenderer.html"><code>
    NOPThrowableRenderer</code></a> in the configuration file in
    order to disable displaying a separate row for the stack trace.
    We don't have the faintest idea why you would want to do that,
    but if you wished, you could.</p>

    <h3>CSS</h3>

    <p>The presentation of the HTML created by
    <code>HTMLLayout</code> is controlled through a Cascading Style
    Sheet (CSS). In the absence of specific instructions,
    <code>HTMLLayout</code> will default to its internal CSS.
    However, your can instruct <code>HTMLLayout</code> to use an
    external CSS file. For this purpose a <code>cssBuilder</code>
    element can be nested within a <code>&lt;layout&gt;</code>
    element, as shown below.</p>
    <pre class="prettyprint source">
&lt;layout&gt;
  ...
  &lt;cssBuilder class="ch.qos.logback.core.html.UrlCssBuilder"&gt;
    &lt;url&gt;path_to_StyleFile.css&lt;/url&gt;
  &lt;/cssBuilder&gt;      
  ...
&lt;/layout&gt;
</pre>

    <p>The <code>HTMLLayout</code> is often used in conjunction
    with <code>SMTPAppender</code>, in order to send an email
    pleasantly formatted in HTML. Here is a typical
    configuration:</p>
    <pre class="prettyprint source">
&lt;configuration&gt;
  &lt;appender name="SMTP" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
      &lt;pattern&gt;%relative%thread%mdc%level%class%msg&lt;/pattern&gt;
    &lt;/layout&gt;
    &lt;From&gt;sender.email@domain.net&lt;/From&gt;
    &lt;SMTPHost&gt;mail.domain.net&lt;/SMTPHost&gt;
    &lt;Subject&gt;LastEvent: %class - %msg &lt;/Subject&gt;
    &lt;To&gt;destination.email@domain.net&lt;/To&gt; 
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="SMTP" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <p><code>HTMLLayout</code> can also be used with any
    <code>FileAppender</code>, including a a rolling file appender,
    as shown in the sample configuration below.</p>
    <pre class="prettyprint source">
&lt;configuration&gt;
   &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
   &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
     &lt;ActiveFileName&gt;lastLogEntries.html&lt;/ActiveFileName&gt;
     &lt;FileNamePattern&gt;logEntries.%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt;
   &lt;/rollingPolicy&gt;
   
   &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
      &lt;cssBuilder class="ch.qos.logback.core.html.UrlCssBuilder"&gt;
        &lt;url&gt;address_of_a_custom_stylesheet.css&lt;/url&gt;
      &lt;/cssBuilder&gt;  
      &lt;Pattern&gt;%relative%thread%mdc%level%logger%msg&lt;/Pattern&gt;
      <b>&lt;Title&gt;Logging Events&lt;/Title&gt;</b>
    &lt;/layout&gt;
 &lt;/appender&gt; 

 &lt;root level="debug"&gt;
   &lt;appender-ref ref="FILE" /&gt;
 &lt;/root&gt;
&lt;/configuration&gt;
</pre>

    <h3><a name="log4jXMLLayout" href="#log4jXMLLayout" id=
    "log4jXMLLayout">Log4j XMLLayout</a></h3>

    <p><a href=
    "../xref/ch/qos/logback/classic/log4j/XMLLayout.html">XMLLayout</a>
    (part of logback-classic) generates output in a log4j.dtd
    compliant format. It can be used to inter-operate with tools
    such as <a href=
    "http://logging.apache.org/chainsaw/index.html">Chainsaw</a>
    and <a href="http://vigilog.sourceforge.net/">Vigilog</a>
    capable of processing files generated by <a href=
    "http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/XMLLayout.html">
    log4j's XMLLayout</a>.</p>

    <p>As the original XMLLayout in log4j version 1.2.15, XMLLayout
    in logback-classic admits two boolean properties, <span class=
    "option">LocationInfo</span> and <span class=
    "option">Properties</span>. Setting <span class=
    "option">LocationInfo</span> to true enables the inclusion of
    location info (caller data) in the each event. Setting
    <span class="option">Properties</span> to true enables the
    inclusion of MDC information. Both options are set to false by
    default.</p>

    <p>Here is a sample configuration</p>
    <pre class="prettyprint source">
&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;File&gt;test.xml&lt;/File&gt;
    &lt;layout class="ch.qos.logback.classic.log4j.XMLLayout"&gt;
      &lt;LocationInfo&gt;true&lt;/LocationInfo&gt;
    &lt;/layout&gt;
  &lt;/appender&gt; 

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt; 
</pre>

    <h2>Logback access</h2>

    <p>Most logback-access layouts are mere adaptations of
    logback-classic layouts. Logback-classic and logback-access
    modules address different needs, but in general offer
    comparable functionality.</p>

    <h3>Writing your own Layout</h3>

    <p>Writing a custom <code>Layout</code> for logback access is
    nearly identical to its sibling<code>Layout</code> in
    logback-classic.</p><a name="AccessPatternLayout" id=
    "AccessPatternLayout"></a>

    <h3>PatternLayout</h3>

    <p><a href=
    "../xref/ch/qos/logback/access/PatternLayout.html"><code>PatternLayout</code></a>
    in logback-access can be configured much in the same way as its
    classic counterpart. However it features additional conversion
    specifiers suited for logging particular bits of information
    availalbe only in HTTP servlet requests and HTTP servlet
    responses.</p>

    <p>Below is a list of conversion specifiers for
    <code>PatternLayout</code> in logback-access.</p>

    <table class="bodyTable" border="0" cellpadding="8">
      <tr>
        <th align="center">Conversion Word</th>

        <th align="center">Effect</th>
      </tr>

      <tr class="a">
        <td align="center"><b>a / remoteIP</b></td>

        <td>
          <p>Remote IP address.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>A / localIP</b></td>

        <td>
          <p>Local IP address.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>b / B / byteSent</b></td>

        <td>
          <p>Response's content length.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>h / clientHost</b></td>

        <td>
          <p>Remote host.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>H / protocol</b></td>

        <td>
          <p>Request protocol.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>l</b></td>

        <td>
          <p>Remote log name. In logback-access, this converter
          always returns the value "-".</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>reqParameter{paramName}</b></td>

        <td>
          <p>Parameter of the response.</p>

          <p>This conversion word takes the first option in braces
          and looks for the corresponding parameter in the
          request.</p>

          <p><b>%reqParameter{input_data}</b> displays the
          corresponding parameter.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>i{header} / header{header}</b></td>

        <td>
          <p>Request header.</p>

          <p>This conversion word takes the first option in braces
          and looks for the corresponding header in the
          request.</p>

          <p><b>%header{Referer}</b> displays the referer of the
          request.</p>

          <p>If no option is specified, it displays every available
          header.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>m / requestMethod</b></td>

        <td>
          <p>Request method.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>r / requestURL</b></td>

        <td>
          <p>URL requested.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>s / statusCode</b></td>

        <td>
          <p>Status code of the request.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>t / date</b></td>

        <td>
          <p>Used to output the date of the logging event. The date
          conversion specifier may be followed by a set of braces
          containing a date and time pattern strings used by
          <code>java.text.SimpleDateFormat</code>.
          <em>ABSOLUTE</em>, <em>DATE</em> or <em>ISO8601</em> are
          also valid values.</p>

          <p>For example, <b>%d{HH:mm:ss,SSS}</b>,
          <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;;HH:mm:ss,SSS}</b> or
          <b>%d{DATE}</b>. If no date format specifier is given
          then ISO8601 format is assumed.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>u / user</b></td>

        <td>
          <p>Remote user.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>U / requestURI</b></td>

        <td>
          <p>Requested URI.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>v / server</b></td>

        <td>
          <p>Server name.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>localPort</b></td>

        <td>
          <p>Local port.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>reqAttribute{attributeName}</b></td>

        <td>
          <p>Attribute of the request.</p>

          <p>This conversion word takes the first option in braces
          and looks for the corresponding attribute in the
          request.</p>

          <p><b>%reqAttribute{SOME_ATTRIBUTE}</b> displays the
          corresponding attribute.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>reqCookie{cookie}</b></td>

        <td>
          <p>Request cookie.</p>

          <p>This conversion word takes the first option in braces
          and looks for the corresponding cookie in the
          request.</p>

          <p><b>%cookie{COOKIE_NAME}</b> displays corresponding
          cookie.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>responseHeader{header}</b></td>

        <td>
          <p>Header of the response.</p>

          <p>This conversion word takes the first option in braces
          and looks for the corresponding header in the
          response.</p>

          <p><b>%header{Referer}</b> displays the referer of the
          response.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>requestContent</b></td>

        <td>
          <p>This conversion word displays the content of the
          request, that is the request's <code>InputStream</code>.
          It is used in conjunction with a <a href=
          "../xref/ch/qos/logback/access/servlet/TeeFilter.html"><code>
          TeeFilter</code></a>, a <code>javax.servlet.Filter</code>
          that replaces the original
          <code>HttpServletRequest</code> by a <a href=
          "../xref/ch/qos/logback/access/servlet/TeeHttpServletRequest.html">
          <code>TeeHttpServletRequest</code></a>. The latter object
          allows access to the request's <code>InputStream</code>
          multiple times without any loss of data.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>fullRequest</b></td>

        <td>
          <p>This converter outputs the data associated with the
          request, including all headers and request contents.</p>
        </td>
      </tr>

      <tr class="b">
        <td align="center"><b>responseContent</b></td>

        <td>
          <p>This conversion word displays the content of the
          response, that is the response's
          <code>InputStream</code>. It is used in conjunction with
          a <a href=
          "../xref/ch/qos/logback/access/servlet/TeeFilter.html"><code>
          TeeFilter</code></a>, a <code>javax.servlet.Filter</code>
          that replaces the original
          <code>HttpServletResponse</code> by a <a href=
          "../xref/ch/qos/logback/access/servlet/TeeHttpServletResponse.html">
          <code>TeeHttpServletResponse</code></a>. The latter
          object allows access to the request's
          <code>InputStream</code> multiple times without any loss
          of data.</p>
        </td>
      </tr>

      <tr class="a">
        <td align="center"><b>fullResponse</b></td>

        <td>
          <p>This conversion word takes all the available data
          associated with the response, including all headers of
          the response and response contents.</p>
        </td>
      </tr>
    </table>

    <p>Logback access' <code>PatternLayout</code> also recognize
    three keywords, which act like shortcuts to a certain
    pattern.</p>

    <table class="bodyTable">
      <tr>
        <th>keyword</th>

        <th>equivalent conversion pattern</th>
      </tr>

      <tr class="a">
        <td><em>common</em> or <em>CLF</em></td>

        <td><em>%h %l %u %t \"%r\" %s %b</em></td>
      </tr>

      <tr class="b">
        <td><em>combined</em></td>

        <td><em>%h %l %u %t \"%r\" %s %b \"%i{Referer}\"
        \"%i{User-Agent}\"</em></td>
      </tr>
    </table>

    <p>The <em>common</em> keyword corresponds to the pattern
    <em>%h %l %u %t \"%r\" %s %b</em> which displays client host,
    remote log name, user, date, requested URL, status code and
    response's content length</p>

    <p>The <em>combined</em> keyword is a shortcut for <em>%h %l %u
    %t \"%r\" %s %b \"%i{Referer}\" \"%i{User-Agent}\"</em>. This
    pattern begins much like the <em>common</em> pattern but also
    displays two request headers, namely referer, and
    user-agent.</p><a name="AccessHTMLLayout" id=
    "AccessHTMLLayout"></a>

    <h3>HTMLLayout</h3>

    <p>The <a href=
    "../xref/ch/qos/logback/access/html/HTMLLayout.html"><code>HTMLLayout</code></a>
    class found in logback-access is similar to the <a href=
    "#ClassicHTMLLayout"><code>HTMLLayout</code></a> class from
    logback-classic.</p>

    <p>By default, it will create a table containing the following
    data:</p>

    <ul>
      <li>Remote IP</li>

      <li>Date</li>

      <li>Request URL</li>

      <li>Status code</li>

      <li>Content Length</li>
    </ul>

    <p>Here is a sample output produced by <code>HTMLLayout</code>
    in logback-access:</p><img src="images/htmlLayoutAccess.gif"
    alt="Access HTML Layout Sample Image" />

    <p>What can be better than a real world example? Our own log4j
    properties for logback <a href=
    "http://logback.qos.ch/translator/">translator</a> makes use of
    logback-access to demonstrate live ouput from
    <code>RollingFileAppender</code> with
    <code>HTMLLayout</code>.</p>

    <p>On every new user request to our <a href=
    "http://logback.qos.ch/translator/">translator</a>
    web-application, a new entry will be added to the access logs,
    which you can view by <a href=
    "http://logback.qos.ch/translator/logs/access.html">following
    this link</a>.</p><script src="../templates/footer.js" type=
    "text/javascript">
</script>
  </div>
</body>
</html>
